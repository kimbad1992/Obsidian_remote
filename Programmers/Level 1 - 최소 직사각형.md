## 🚩 문제
><h4>문제설명</h4>
명함 지갑을 만드는 회사에서 지갑의 크기를 정하려고 합니다. 다양한 모양과 크기의 명함들을 모두 수납할 수 있으면서, 작아서 들고 다니기 편한 지갑을 만들어야 합니다. 이러한 요건을 만족하는 지갑을 만들기 위해 디자인팀은 모든 명함의 가로 길이와 세로 길이를 조사했습니다.
>
>아래 표는 4가지 명함의 가로 길이와 세로 길이를 나타냅니다.
>
|**명함 번호**|**가로 길이**|**세로 길이**|
|---|---|---|
|1|60|50|
|2|30|70|
|3|60|30|
|4|80|40|
>
가장 긴 가로 길이와 세로 길이가 각각 80, 70이기 때문에 80(가로) x 70(세로) 크기의 지갑을 만들면 모든 명함들을 수납할 수 있습니다. 하지만 2번 명함을 가로로 눕혀 수납한다면 80(가로) x 50(세로) 크기의 지갑으로 모든 명함들을 수납할 수 있습니다. 이때의 지갑 크기는 4000(=80 x 50)입니다.
>
모든 명함의 가로 길이와 세로 길이를 나타내는 2차원 배열 sizes가 매개변수로 주어집니다. 모든 명함을 수납할 수 있는 가장 작은 지갑을 만들 때, 지갑의 크기를 return 하도록 solution 함수를 완성해주세요.
>
><h4>제한사항</h4>
>
 * sizes의 길이는 1 이상 10,000 이하입니다.
   - sizes의 원소는 [w, h] 형식입니다.
   - w는 명함의 가로 길이를 나타냅니다.
   - h는 명함의 세로 길이를 나타냅니다.
   - w와 h는 1 이상 1,000 이하인 자연수입니다.
>
----
><h4>입출력 예</h4>
>
|**sizes**|**result**|
|---|---|
|[[60, 50], [30, 70], [60, 30], [80, 40]]|4000|
|[[10, 7], [12, 3], [8, 15], [14, 7], [5, 15]]|120|
|[[14, 4], [19, 6], [6, 16], [18, 7], [7, 11]]|133|
>
>_출처: 프로그래머스 코딩 테스트 연습, https://school.programmers.co.kr/learn/challenges_

<br>
<br>

## 🌌 생각
 * "가로로 눕혔을 때"... 모든 원소를 뒤집어서 대조해야 하나?
 * 가로보다 세로가 큰 경우만 뒤집어서 비교하기로 했다.
 * 결국엔 명함들을 각잡아서 놨을 때 모든 명함이 들어가는 지갑이 필요하다.
 * 원소들 중 (가로에서 제일 큰 값 * 세로에서 제일 큰 값)을 계산하면 될 것 같다.
 
 <br>
 <br>
 
## 📝 코드 작성

```java
class Solution {
    public int solution(int[][] sizes) {
        int[] max = new int[2];
        for (int i=0; i<sizes.length; i++) {
            if (sizes[i][0] < sizes[i][1]) { // 세로가 더 큰 경우 뒤집는다
                int tmp = 0;
                tmp = sizes[i][0];
                sizes[i][0] = sizes[i][1];
                sizes[i][1] = tmp;
            }
            if (max[0] <= sizes[i][0]) {
                max[0] = sizes[i][0];
            }
            if (max[1] <= sizes[i][1]) {
                max[1] = sizes[i][1];
            }
        }
        
        return max[0] * max[1];
    }
}
````
사이즈 다른 명함 겹쳐놓고 얘네가 다 들어갈 수 있는 크기의 지갑을 만들어야 하니
가장 큰 값만 가져와 넓이를 구해주면 되는거였다.

<br>
<br>

## ✔️ 다른 사람의 코드
```java
class Solution {
    public int solution(int[][] sizes) {
        int length = 0, height = 0;
        for (int[] card : sizes) {
            length = Math.max(length, Math.max(card[0], card[1]));
            height = Math.max(height, Math.min(card[0], card[1]));
        }
        int answer = length * height;
        return answer;
    }
}

```
`Math.max`와 `Math.min`을 사용한 간결한 코드
이런 풀이를 보면 내 수학적 소양이 많이 부족함을 다시금 느끼게 된다
